<!DOCTYPE html>
<html>
<head>
  <title>강화 시뮬레이터</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 40px;
      background-color: #edf0c0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .card {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.15);
      max-width: 800px;
      width: 100%;
      text-align: left;
      box-sizing: border-box;
    }

    .form-wrapper {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }

    .form-wrapper label {
      display: block;
      width: 100%;
      font-weight: normal;
    }

    input[type="number"], input[type="text"] {
      width: 150px;
      padding: 4px 6px;
      margin-left: 10px;
      font-size: 14px;
    }

    button {
      width: 160px;
      padding: 8px 12px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
      align-self: flex-start;
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 6px;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #45a049;
    }

    #result {
      white-space: pre-wrap;
      background-color: #f9f9f9;
      padding: 15px;
      border: 1px solid #ddd;
      height: 250px;
      overflow-y: auto;
      margin-bottom: 30px;
      font-family: monospace;
      font-size: 14px;
    }

    canvas#histChart {
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      max-width: 100%;
      height: 380px !important;
    }

    label.blessing {
      color: #321ee9;
      font-weight: bold;
    }

    label.favour {
      color: #e91eac;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1 style="text-align:center; margin-bottom: 30px;">강화 시뮬레이터</h1>

    <div class="form-wrapper">
      <label>시작 레벨: <input type="number" id="startLevel" value="20"></label>
      <label>목표 레벨: <input type="number" id="endLevel" value="30"></label>
      <label>시도 횟수 (num_runs): <input type="number" id="numRuns" value="10000" readonly style="background-color: #eee; color: #555;"></label>
      <label class="blessing">태양의 축복 가격: <input type="number" id="blessingPrice" value="10000"></label>
      <label class="favour">태양의 가호 가격: <input type="number" id="favourPrice" value="150000"></label>
      <label class="blessing">태양의 축복 사용할 레벨 (쉼표로 구분): <input type="text" id="blessingLevels" value="24,25,26,27,28"></label>
      <label class="favour">태양의 가호 사용할 레벨 (쉼표로 구분): <input type="text" id="favourLevels" value="27,28,29"></label>
      <button onclick="runSimulation()">시뮬레이션 실행</button>
    </div>

    <pre id="result"></pre>
    <canvas id="histChart" width="600" height="300"></canvas>
  </div>

<script>
  const upgrade_data = {
  	0: {"token": 100, "solar": 0, "probability": 100},
  	1: {"token": 100, "solar": 0, "probability": 100},
  	2: {"token": 100, "solar": 0, "probability": 100},
  	3: {"token": 200, "solar": 0, "probability": 90},
  	4: {"token": 400, "solar": 0, "probability": 70},
  	5: {"token": 500, "solar": 0, "probability": 60},
  	6: {"token": 700, "solar": 0, "probability": 45},
  	7: {"token": 700, "solar": 0, "probability": 45},
  	8: {"token": 700, "solar": 0, "probability": 45},
  	9: {"token": 700, "solar": 0, "probability": 45},
  	10: {"token": 700, "solar": 0, "probability": 45},
  	11: {"token": 700, "solar": 0, "probability": 45},
  	12: {"token": 800, "solar": 0, "probability": 40},
  	13: {"token": 800, "solar": 0, "probability": 40},
  	14: {"token": 800, "solar": 0, "probability": 40},
  	15: {"token": 1000, "solar": 16, "probability": 40},
  	16: {"token": 1000, "solar": 17, "probability": 35},
  	17: {"token": 1000, "solar": 18, "probability": 35},
  	18: {"token": 1000, "solar": 19, "probability": 35},
  	19: {"token": 1000, "solar": 20, "probability": 35},
  	20: {"token": 1000, "solar": 21, "probability": 35},
  	21: {"token": 2000, "solar": 22, "probability": 35},
  	22: {"token": 2000, "solar": 23, "probability": 30},
  	23: {"token": 2000, "solar": 24, "probability": 30},
  	24: {"token": 2000, "solar": 25, "probability": 30},
  	25: {"token": 2000, "solar": 26, "probability": 30},
  	26: {"token": 2000, "solar": 27, "probability": 30},
  	27: {"token": 2000, "solar": 28, "probability": 25},
  	28: {"token": 2000, "solar": 29, "probability": 25},
  	29: {"token": 2000, "solar": 30, "probability": 25},
  	30: {"token": 2000, "solar": 31, "probability": 25},
  	31: {"token": 4000, "solar": 32, "probability": 25},
  	32: {"token": 4000, "solar": 33, "probability": 25},
  	33: {"token": 4000, "solar": 34, "probability": 25},
  	34: {"token": 4000, "solar": 35, "probability": 25},
  	35: {"token": 4000, "solar": 36, "probability": 25},
  	36: {"token": 4000, "solar": 37, "probability": 25},
  	37: {"token": 4000, "solar": 38, "probability": 25},
  	38: {"token": 4000, "solar": 39, "probability": 25},
  	39: {"token": 4000, "solar": 40, "probability": 25},
  };

  function item_cost(level) {
    if (level <= 9) return 5;
    if (level <= 18) return 10;
    return 15;
  }

  function parseSet(input) {
    return new Set(
      input
        .replace(/\s+/g, '')
        .split(',')
        .map(x => parseInt(x))
        .filter(x => !isNaN(x))
    );
  }

  function simulate_upgrade(path, blessing_levels, favour_levels, blessing_price, favour_price) {
    let level = path.start_level;
    const target = path.end_level;
    let attempts = 0;
    let total_token = 0;
    let total_solar = 0;
    let blessing_used = 0;
    let favour_used = 0;
    let grade_level = [10, 20, 30];

    while (level < target) {
      if (grade_level.includes(level) && level !== path.start_level) {
        total_token += 30520;
        grade_level = grade_level.filter(g => g !== level);
      }

      attempts++;
      const stage = upgrade_data[level];

      total_token += stage.token;
      total_solar += stage.solar;

      const success = Math.random() < stage.probability / 100;

      const useFavour = favour_levels && favour_levels.has(level);
      const useBlessing = blessing_levels && blessing_levels.has(level);

      favour_used += useFavour ? item_cost(level) : 0;
      blessing_used += useBlessing ? item_cost(level) : 0;

      if (success) {
        level++;
        if (useBlessing) {
          const roll = Math.random();
          let extra = 0;
          if (roll < 1 / 6) extra = 2;
          else if (roll < (1 / 6 + 1 / 3)) extra = 1;
          const max_limit = target;
          level = Math.min(level + extra, max_limit);
        }
      } else {
        if ([10, 20, 30].includes(level) || useFavour) {
          //pass
        } else if ((Math.random() < 0.8 && level < 25) || level >= 25) {
          level -= 1;
        }
      }
    }

    return [attempts, total_token, total_solar, blessing_used, favour_used];
  }

  let chartInstance = null;

  function formatNumberShort(num) {
    if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
    return num.toString();
  }

  function createHistogram(data, binCount) {
    const min = Math.min(...data);
    const max = Math.max(...data);
    const binSize = (max - min) / binCount;
    const bins = new Array(binCount).fill(0);

    data.forEach(value => {
      let idx = Math.floor((value - min) / binSize);
      if (idx === binCount) idx = binCount - 1;
      bins[idx]++;
    });

    const labels = [];
    for (let i = 0; i < binCount; i++) {
      const rangeStart = min + binSize * i;
      const rangeEnd = rangeStart + binSize;
      labels.push(`${formatNumberShort(Math.round(rangeStart))}~${formatNumberShort(Math.round(rangeEnd))}`);
    }

    return { bins, labels };
  }

  function smoothLine(data, windowSize = 10) {
    const smoothed = [];
    for (let i = 0; i < data.length; i++) {
      let sum = 0;
      let count = 0;
      for (let j = i - Math.floor(windowSize / 2); j <= i + Math.floor(windowSize / 2); j++) {
        if (j >= 0 && j < data.length) {
          sum += data[j];
          count++;
        }
      }
      smoothed.push(sum / count);
    }
    return smoothed;
  }

  function run_simulations(path, num_runs, blessing_levels, favour_levels, blessing_price, favour_price) {
    let total_attempts = 0;
    let total_tokens = 0;
    let total_solars = 0;
    let total_blessings = 0;
    let total_favours = 0;
    const total_token_lst = [];

    for (let i = 0; i < num_runs; i++) {
      const [attempts, tokens, solars, blessings, favours] = simulate_upgrade(path, blessing_levels, favour_levels, blessing_price, favour_price);
      total_attempts += attempts;
      total_tokens += tokens;
      total_solars += solars;
      total_blessings += blessings;
      total_favours += favours;
      total_token_lst.push(tokens + blessings * blessing_price + favours * favour_price);
    }

    const avg_attempts = total_attempts / num_runs;
    const avg_tokens = total_tokens / num_runs;
    const avg_solars = total_solars / num_runs;
    const avg_blessings = total_blessings / num_runs;
    const avg_favours = total_favours / num_runs;
    const total_cost = avg_tokens + avg_blessings * blessing_price + avg_favours * favour_price;
    const min_cost = Math.min(...total_token_lst);
    const max_cost = Math.max(...total_token_lst);
    const std = Math.sqrt(total_token_lst.reduce((sum, val) => sum + (val - total_cost) ** 2, 0) / num_runs);

    let resultText =
      `Simulated ${num_runs.toLocaleString()} runs from Level ${path.start_level.toLocaleString()} to ${path.end_level.toLocaleString()}:\n`;

    if (blessing_levels && blessing_levels.size > 0) {
      resultText += `* Blessing applied at levels: [${[...blessing_levels].sort((a,b)=>a-b).join(', ')}]\n`;
    }
    if (favour_levels && favour_levels.size > 0) {
      resultText += `* Favour applied at levels: [${[...favour_levels].sort((a,b)=>a-b).join(', ')}]\n`;
    }

    resultText += `\nAverage Attempts >>> ${avg_attempts.toFixed(2)}\n` +
      `Average Token Cost(upgrade only) >>> ${Math.round(avg_tokens).toLocaleString()}\n` +
      `Average Solar Energy Cost >>> ${Math.round(avg_solars).toLocaleString()}\n` +
      `Average Blessing Items Used >>> ${Math.round(avg_blessings).toLocaleString()}\n` +
      `Average Favour Items Used >>> ${Math.round(avg_favours).toLocaleString()}\n\n` +
      `Total Estimated Token Cost (including blessing & favour) >>> ${Math.round(total_cost).toLocaleString()}\n` +
      `Best Token Cost Case >>> ${min_cost.toLocaleString()}\n` +
      `Worst Token Cost Case >>> ${max_cost.toLocaleString()}\n` +
      `Std >>> ${Math.round(std).toLocaleString()}`;

    document.getElementById("result").textContent = resultText;

    const ctx = document.getElementById('histChart').getContext('2d');

    if (chartInstance) {
      chartInstance.destroy();
    }

    const binCount = 50;
    const { bins, labels } = createHistogram(total_token_lst, binCount);
    const smoothBins = smoothLine(bins, 5);

    chartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            type: 'bar',
            label: '비용 히스토그램',
            data: bins,
            backgroundColor: 'rgba(75, 192, 192, 0.6)',
            borderWidth: 1,
          },
          {
            type: 'line',
            label: '분포선 (이동평균)',
            data: smoothBins,
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 2,
            fill: false,
            tension: 0.3,
            yAxisID: 'y',
          }
        ]
      },
      options: {
        responsive: true,
        scales: {
          y: {
            beginAtZero: true,
            position: 'left',
            title: { display: true, text: '빈도' }
          },
          x: {
            display: false,
            title: { display: false },
            ticks: { display: false }
          }
        },
        plugins: {
          legend: { display: true },
          tooltip: { enabled: true },
          title: {
            display: true,
            text: `비용 분포 및 히스토그램 (${num_runs.toLocaleString()}개 샘플)`,
            font: { size: 18 }
          }
        }
      }
    });
  }

  function runSimulation() {
    const path = {
      start_level: parseInt(document.getElementById('startLevel').value),
      end_level: parseInt(document.getElementById('endLevel').value)
    };
    const num_runs = parseInt(document.getElementById('numRuns').value);
    const blessing_price = parseInt(document.getElementById('blessingPrice').value);
    const favour_price = parseInt(document.getElementById('favourPrice').value);
    const blessing_levels = parseSet(document.getElementById('blessingLevels').value);
    const favour_levels = parseSet(document.getElementById('favourLevels').value);

    run_simulations(path, num_runs, blessing_levels, favour_levels, blessing_price, favour_price);
  }
</script>
</body>
</html>
